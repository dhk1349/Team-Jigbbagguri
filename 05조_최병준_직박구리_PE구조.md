# PE구조_최병준

PE(Portable Executable)

- MS에서 다른 운영체제와 이식성을 좋게 하기 위해 만든 파일 포맷임

공부하는 이유

- PE구조를 알면 파일이 실행되기 위한 모든 정보를 알 수 있음
- 어느 메모리주소에 파일이 로딩되는지 알 수 있음
- 메모리 분석하기에 앞서, PE 구조 공부가 우선시 된다고 생각했음

예상 결과물

- PE 구조에 대한 전체적인 개념 보고서
- PE 구조를 파싱하는 파이썬 코드 작성

---

### 순서

1. 꼭 알고 가야할 내용들
2. Memory 순서
3. DOS Header
4. DOS stub
5. NT header

---

### 꼭 알고 가야할 내용들

절대주소? 상대주소?

- VA(virtual address) 
  - 메모리의 절대주소를 말함
- RVA(Relative virtual address)
  - 어떤 기준에서부터의 상대주소
  - PE = 메모리에 적재되기 전에는 ImageBase(기준)이 0
  - 이후, PE 안에서는, 상대주소로 주소가 입력됨

상대주소를 굳이 쓰는 이유

- Relocation, 즉 재배치가 이루어질 때, 절대주소로 되어있으면 불가능하기 때문

이 둘의 관계

- RVA + ImageBase = VA

---

### Memory 순서

DOS header

DOS stub

NT header

Section header1

Section header2

NULL

Section1

NULL

Section2

NULL

#### 잠깐

section header의 끝부분과 각각의 section 끝에 NULL 값으로 채워진 이유

- 메모리에 기본적으로 올라가는 크기가 실제 파일의 크기보다 크기 때문에 남는 공간을 NULL로 채워줌

---

### DOS Header (메모리 맨 앞)

- #### IMAGE_DOS_HEADER 구조체를 보면

```c
typedef struct _IMAGE_DOS_HEADER {     
    WORD   e_magic;          // DOS signature : 4D5A ("MZ")
    WORD   e_cblp;                    
    WORD   e_cp;                      
    WORD   e_crlc;                    
    WORD   e_cparhdr;                 
    WORD   e_minalloc;                
    WORD   e_maxalloc;                
    WORD   e_ss;                      
    WORD   e_sp;                      
    WORD   e_csum;                    
    WORD   e_ip;                      
    WORD   e_cs;                      
    WORD   e_lfarlc;                  
    WORD   e_ovno;                    
    WORD   e_res[4];                  
    WORD   e_oemid;                   
    WORD   e_oeminfo;                 
    WORD   e_res2[10];                  
    LONG   e_lfanew;         // offset to NT header 
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

- e_magic
  - DOS signature가 있음 (0x4D5A	ASCII : MZ)
  - 모든 PE 파일 시작 부분에는 e_magic이 존재함
- e_lfanew
  - NT header의 offset을 표시함
  - 이 변수가 가리키는 위치에 NT header 구조체가 존재함(_IMAGE_NT_HEADERS)

---

### DOS stub

- 옵션에 의해 있을수도 or 없을수도
- 크기도 일정하지 않음
- 하지만, DOS stub 없이도 파일 실행에는 문제가 없음

---

### NT header

- #### IMAGE_NF_HEADERS 구조체를 보면

```c
typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;       // PE Signature : 50450000 ("PE"00)
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

- Signature 변수가 NT header 구조체의 시작을 알려줌 (=PE)

- #### _IMAGE_FILE_HEADER 구조체를 보면

```c
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

- Machine
  - CPU별로 고유한 값을 가짐
  - IA-32호환CPU = 14Ch
  - IA-64호환CPU = 200h
  
- TimeDateStamp

  - 이 파일이 빌드된 날짜가 타임스탬프 형식으로 기록됨
  - 하지만, 변조가 가능하므로 대략적인 값으로 생각해야 함

- NumberofSections
  
  - Section들의 개수 (최소 1개 이상)
  
- SizeOfOptionalHeader
  
  - IMAGE_NF_HEADERS 구조체의 마지막 구조체인 IMAGE_OPTIONAL_HEADER 32의 구조체 크기를 나타냄
  
- Characteristics
  
- 파일 속성에 대한 부분임
  
- #### IMAGE_OPTIONAL_HEADER 32 구조체를 보면

```c
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
 
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
 
typedef struct _IMAGE_OPTIONAL_HEADER {
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

- Magic
- Optional Header를 구분하는 시그니처임
  - 32bit면 0x10B
  - 64bit면 0x20B
- SizeOfCode
  - IMAGE_SCN_CNT_CODE 속성을 가진 섹션들의 총 사이즈를 담고 있음
- AddressOfEntryPoint

  - PE 파일이 메모리에 로드된 후 맨 처음 실행되어야 하는 코드의 주소를 담고 있음
  - VA가 아닌 RVA 값 즉 ImageBase로부터의 offset이 기록됨
- BaseOfCode
  - 
- ImageBase
  - PE파일이 매핑되는 시작주소를 가리킴
- SectionAlignment
  - 메모리에서의 최소 섹션 단위를 나타냄
- FileAlignment
  - 파일에서의 최소 섹션 단위를 나타냄

---

### Section header

- #### IMAGE_SECTION_HEADER 구조체를 보면 

```c
#define IMAGE_SIZEOF_SHORT_NAME        8
 
typedef struct _IMAGE_SECTION_HEADER {
  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
  union {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
  } Misc;
  DWORD VirtualAddress;
  DWORD SizeOfRawData;
  DWORD PointerToRawData;
  DWORD PointerToRelocations;
  DWORD PointerToLinenumbers;
  WORD  NumberOfRelocations;
  WORD  NumberOfLinenumbers;
  DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

- Name

  - Section 이름을 나타냄 (참고용임)

- VirtualSize

  -   PE 파일이 메모리에 로드된 후 섹션이 차지하는 크기

- VirtualAddress

  - 섹션의 RVA값 (ImageBase + VA)

- SizeOfRawData

  - 파일 상에서 섹션이 차지하는 크기

- PointerToRawData

  - 파일 상에서 섹션이 시작하는 위치

  

[DIRECTORY_ENTRY_IMPORT]
는 뭐있는지 잘모르겠는데 중요함
DLL이랑 API 목록 가져옴





출처

https://rednooby.tistory.com/33